# 13장. 동시성

### 동시성 프로그래밍

- 어플리케이션을 효율적으로 실행하기 위해 멀티코어를 온전히 활용하도록 구현하는 방식
- 낭비되는 자원을 줄이는 것

ex)  음식점

→ 목적  : 음식을 많이 제공한다 = 처리량을 높여 돈을 번다

- 동시성이 구현되지 않은 경우
    
    손님1 피자요청 → 서버1 피자요리대기 → 손님1 → 손님2 무한대기
    
- 병렬성이 구현된 경우 (코어 증설)
    
    손님1 피자요청 → 서버1 피자요리대기 → 손님1
    
    손님2 피자요청 → 서버2 피자요리대기 → 손님2
    
- 동시성을 구현한 경우
    
    손님1 피자요청 → 피자요리 → 서버1 청소 → .서버1 계산 → 서버1 피자서빙
    

 동시성을 구현한다고 클라이언트 입장에서 요청이 빨리 처리되는건 아님
     어플리케이션 입장에서는 효율적인 코어를 사용해 처리량을 높일 수 있다.

클라이언트가 아닌 어플리케이션 관점에서 봐야한다.

### 동시성 프로그래밍이 필요한 이유

- 동시성은 때로 성능을 높여준다.
    - 대기 시간이 아주 길어 여러 스레드가 프로세서를 공유할 수 있거나, 여러 프로세서가 동시에 처리할 독립적인 계산이 충분히 많은 경우에만 성능이 높아진다.
- Java Servlet동시성 구현
    - 요청이 들어오면 Thread Pool에 있는 Thread가 서블릿의 service()메서드를 호출한다.
- 동시성을 구현하면 설계를 바꿔야 한다.
    - 단일 스레드 시스템과 다중 스레드 시스템은 설게가 판이하게 다르다.
    - '무엇'과 '언제'를 분리하면 시트메의 구조가 크게 달라진다.
- 컨테이너를 사용해도 동시성을 이해해야 한다.
    - 어플리케이션이 컨테이너를 통해 멀티 쓰레드를 사용하는 것이기 때문에 컨테이너의 동작을 이해해야 한다.

### 단일 책임 원칙 (SRP) 설계

- 동시성 관련 코드는 다른 코드와 분리하라
    - 동시성 코드는 독자적인 개발,변경,조율 주기가 있다.
    - 동시성 코드에는 독자적인 난관이 있다. 다른 코드에서 겪는 난관과 다르며 훨씬 어렵다.
    - 동시성 코드는 다른 코드와 분리해서 작성해주는 것이 좋다.
    
- 자료 범위를 제한하라
    - 공유 자료를 최대한 줄여라
    - 동시 수정 문제를 피하기 위해 객체를 사용하는 코드 내 임계영역을 synchronized 키워드로 보호하라
    - 임계 영역의 수를 최소화 해야 한다
    
- 자료 사본을 사용하라.
    - 공유 자료를 줄이려면, 최대한 공유하지 않는 방법이 제일 좋다.
    - 객체를 복사해 읽기 전용으로 사용한다.
    - 각 스레드가 객체를 복사해 사용한 후 한 스레드가 해당 사본에서 결과를 가져온다.
    - 여러가지 스레드를 가지고 같은 변수를 수정할때는 사용할 수 없음 하지만 여러가지 스레드가 어떤 값을 같이 동시에 읽을 수 있을 때 사본으로 로컬변수로 사용
    
- Thread는 가능한 독립적으로 구현하라
    - 다른 스레드와 자료를 공유하지 않는다.
    - 서블릿처럼 각 Thread는 클라이언트 요청 하나를 처리한다

- 라이브러리를 이해하라
    - java.util.concurrent

- 동기화하는 메서드 사이에 존재하는 의존성을 이해하라
    - 클라이언트에서 잠금-클라이언트에서 첫번재 메서드를 호출하기 전에 서버를 잠근다.
    - 서버에서 잠금 - 서버에다 "서버를 잠그고 모든 메서드를 호출한 후 잠금을 해제하는" 메서드를 구현
    - Adapter 서버 - 잠금을 수행하는 중간단계를 생성한다.

### 동시성 테스트 방법

- 동시성 코드를 테스트 해야 한다.
    - 동시성 코드가 100% 올바르다고 증명하기는 불가능하다.
    - 프로그램의 설정과 시스템 설정과 부하를 바꿔가며 자주 돌려라
    
- 코드에 보조 코드를 넣어 돌려라
    - 드물게 발생하는 오류를 자주 발생시키도록 보조 코드를 추가한다.
    
- 동시성 코드를 실제 환경이나 테스트 환경에서 돌려본다.
    - 배포하기 전에 테스트 환경에서 충분히 오랜시간 검증한다.

### 오픈 소스 속 동시성 처리

- Elastic Search - LockingAtomicCounter
    - AtomicLog
        - Long 자료형을 thread safe하게 랩핑한 값
        - CPU 레벨의 연산인 CAS(compare-and-swap)을 지원해서 thread safe하게 값을 사용할 수 있다.
    - ReentrantReadWriteLock
        - 동시에 읽는 스레드는 허용하지만 읽기&쓰기, 쓰기&쓰기의 경우에는 차단한다.
        - 읽는 작업이 자주 일어나고 쓰는 작업이 적을 때 사용하면 좋다
        
        ```java
        public boolean compareAndRun(long count, Runnable runnable){
        	assert count >= 0: "Count must be non-negative";
        	try (ReleasableLock ignored = countingReadLock.acquire()){
        		if (count == counter.get()){
        			logger.debug("Count matches [{}], executing runnable",count);
        			runnable.run();
        			return true;
        		}
        	}
        	return false;
        }
        ```