# 함수

> 함수를 안전하고 간결하게 작성하기

### SOLID원칙

1. SRP(단일책임원칙)
2. OCP(개방-폐쇄원칙)
3. LSP(리스코프치환원칙)
4. ISP(인터페이스분리원칙)
5. DIP(의존성역전원칙)

### SRP
+ 클래스는 하나의 기능만 가진다.

### OCP
+ 확장에는 열려 있으나 변경에는 닫혀 있어야한다.
+ 객체지향의 추상화와 다형성을 활용한다.

### LSP
+ 서브 타입은 언제나 기반 타입으로 교체할 수 있어야 한다.
+ 클래스 상속, 인터페이스 상속을 이용해 확장성을 획득
+ 다형성과 확장성을 극대화하기 위해 인터페이스를 사용하는 것이 더 좋다.
+ 자식클래스도 부모클래스의 기능을 구현할 수 있어야 한다.
  - 상속보다는 구현을 많이 이용하라

### ISP
+ 사용하지 않는 인터페이스는 구현하지 말아야 한다.
+ 가능한 최소한의 인터페이스만 구현한다.
  - 인터페이스를 뚱뚱하게 만들지 말자.
+ SRP가 클래스의 단일 책임이라면, ISP는 인터페이스의 단일 책임이다.

### DIP
+ 상위 모델은 하위 모델에 의존하면 안된다. 둘 다 추상화에 의존해야 한다.
+ 추상화는 세부 사항에 의존해서는 안된다. 세부 사항은 추상황에 따라 달라진다.

### 간결한 함수 작성하기
+ 함수를 가능한한 작게 쪼갠다.
+ 함수 내 추상화 수준을 동일하게 맞춘다.

### 함수 인수
+ 함수 인수의 갯수는 0~2개가 적당하다.
+ 3개 이상이 경우에는? -> 객체로 묶는다.
+ 가변인자를 넘기는 경우는 현업에서 많지 않다.

### 부수 효과 없는 함수
+ 값을 반환하는 함수가 외부 상태를 변경하는 경우
+ 세션을 초기화하는 예제

### 함수 리팩터링
1. 기능을 구현하는 서투른 함수를 작성(길고 복잡하고 중복이 많다)
2. 테스트 코드를 작성 (빠짐 없이)
3. 리팩터링 (코드를 다듬고, 함수를 쪼개고, 이름을 바꾸고, 중복을 제거)

# 삼색 볼펜 표시
1. 함수를 만드는 첫째 규칙은 작게!다, 함수를 만드는 둘째 규칙은 더 작게!다.(p42)
2. 함수에서 들여쓰기 수준은 1단이나 2단을 넘어서면 안 된다.(p44)
3. 함수는 한 가지를 해야 한다. 그 한 가지를 잘 해야 한다. 그 한 가지만을 해야 한다.(p44)
4. 함수가 '한가지'만 하는지 판단하는 방버이 하나 더 있다. 단순히 다른 표현이 아니라 의미 있는 이름으로 다른 함수를
추출할 수 있다면 그 함수는 여러 작업을 하는 셈이다.(p45)
5. switch 문은 작게 만들기 어렵다. 또한 '한 가지'작업만 하는 switch 문도 만들기 어렵다.(p47)
6. 함수가 작고 단순할수록 서술저긴 이름을 고르기도 쉬워진다.(p49)
7. 함수에서 이상적인 인수 갯수는 0개다.(p50)
8. 플래그 인수는 추하다. 함수가 한꺼번에 여러 가지 처리한다고 대놓고 공표하는 셈이니까(p52)
9. 객체 지향 언어에서는 출력 인수를 사용할 필요가 거의 없다. 일반적으로 출력 인수는 피해야 한다.(p56)
10. 해결책은 명령과 조회를 분리해 혼란을 애초에 뿌리뽑는 방법이다.(p57)
11. 오류 코드보다 예외를 사용하라!(p57)
12. 오류 처리도 한 가지 작업이다.(p59)
13. 중복은 소프트웨어에서 모든 악의 근원이다.(p60)
14. 함수를 어떻게 짜죠?(p61)
